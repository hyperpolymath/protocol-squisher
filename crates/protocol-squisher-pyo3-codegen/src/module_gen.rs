// SPDX-License-Identifier: PMPL-1.0
// SPDX-FileCopyrightText: 2025 hyperpolymath

//! Module code generation for PyO3
//!
//! Generates complete PyO3 modules from IR schemas.

use crate::enum_gen::{generate_enum, EnumGenConfig};
use crate::mapping::MappingContext;
use crate::struct_gen::{generate_struct, StructGenConfig};
use protocol_squisher_ir::{schema::topological_sort, IrSchema, TypeDef};

/// Configuration for module generation
#[derive(Debug, Clone)]
pub struct ModuleGenConfig {
    /// Name of the generated module
    pub module_name: String,
    /// Struct generation config
    pub struct_config: StructGenConfig,
    /// Enum generation config
    pub enum_config: EnumGenConfig,
    /// Add serde derive to types
    pub add_serde_derive: bool,
    /// Generate type stubs (.pyi file content)
    pub generate_stubs: bool,
    /// Include module docstring
    pub module_doc: Option<String>,
}

impl Default for ModuleGenConfig {
    fn default() -> Self {
        Self {
            module_name: "generated".to_string(),
            struct_config: StructGenConfig::default(),
            enum_config: EnumGenConfig::default(),
            add_serde_derive: true,
            generate_stubs: true,
            module_doc: None,
        }
    }
}

impl ModuleGenConfig {
    /// Create a new config with the given module name
    pub fn new(module_name: impl Into<String>) -> Self {
        Self {
            module_name: module_name.into(),
            ..Default::default()
        }
    }

    /// Set module documentation
    pub fn with_doc(mut self, doc: impl Into<String>) -> Self {
        self.module_doc = Some(doc.into());
        self
    }
}

/// Result of generating a module
#[derive(Debug, Clone)]
pub struct GeneratedModule {
    /// The Rust source code
    pub rust_code: String,
    /// Python type stub content (if generated)
    pub python_stub: Option<String>,
    /// List of types that were generated
    pub generated_types: Vec<String>,
    /// List of types that were referenced but not defined
    pub missing_types: Vec<String>,
}

/// Generate a complete PyO3 module from an IR schema
pub fn generate_module(schema: &IrSchema, config: &ModuleGenConfig) -> GeneratedModule {
    let mut ctx = MappingContext::new();
    let mut type_codes: Vec<String> = Vec::new();
    let mut generated_types = Vec::new();

    // Sort types topologically to ensure dependencies come first
    let type_order = topological_sort(schema).unwrap_or_else(|_| {
        // Fallback to arbitrary order if circular references
        schema.types.keys().cloned().collect()
    });

    // Generate code for each type
    for type_name in &type_order {
        if let Some(type_def) = schema.types.get(type_name.as_str()) {
            let code = match type_def {
                TypeDef::Struct(s) => generate_struct(s, &config.struct_config, &mut ctx),
                TypeDef::Enum(e) => generate_enum(e, &config.enum_config, &mut ctx),
                TypeDef::Alias(a) => generate_alias(a),
                TypeDef::Newtype(n) => generate_newtype(n),
                TypeDef::Union(u) => generate_union(u),
            };
            type_codes.push(code);
            generated_types.push(type_name.clone());
        }
    }

    // Build the complete module
    let rust_code = build_rust_module(config, &type_codes);

    // Generate Python stubs if requested
    let python_stub = if config.generate_stubs {
        Some(generate_python_stubs(schema, &generated_types))
    } else {
        None
    };

    GeneratedModule {
        rust_code,
        python_stub,
        generated_types,
        missing_types: ctx.pending_types,
    }
}

/// Build the complete Rust module code
fn build_rust_module(config: &ModuleGenConfig, type_codes: &[String]) -> String {
    let mut code = String::new();

    // File header
    code.push_str("// SPDX-License-Identifier: PMPL-1.0\n");
    code.push_str("// SPDX-FileCopyrightText: 2025 hyperpolymath\n");
    code.push_str("// Generated by protocol-squisher-pyo3-codegen\n\n");

    // Module doc
    if let Some(ref doc) = config.module_doc {
        code.push_str(&format!("//! {}\n\n", doc));
    }

    // Imports
    code.push_str("use pyo3::prelude::*;\n");
    if config.add_serde_derive {
        code.push_str("use serde::{Deserialize, Serialize};\n");
    }
    code.push('\n');

    // Type definitions
    for type_code in type_codes {
        code.push_str(type_code);
        code.push('\n');
    }

    // Module definition
    code.push_str(&format!(
        "/// Python module generated from IR schema\n\
         #[pymodule]\n\
         fn {}(m: &Bound<'_, PyModule>) -> PyResult<()> {{\n",
        config.module_name
    ));

    // Register each type
    for type_code in type_codes {
        // Extract type name from the code
        if let Some(name) = extract_type_name(type_code) {
            code.push_str(&format!("    m.add_class::<{}>()?;\n", name));
        }
    }

    code.push_str("    Ok(())\n");
    code.push_str("}\n");

    code
}

/// Extract the type name from generated code
fn extract_type_name(code: &str) -> Option<String> {
    // Look for "pub struct Name" or "pub enum Name"
    for line in code.lines() {
        if let Some(rest) = line.strip_prefix("pub struct ") {
            let name = rest.split_whitespace().next()?;
            return Some(name.trim_end_matches('{').to_string());
        }
        if let Some(rest) = line.strip_prefix("pub enum ") {
            let name = rest.split_whitespace().next()?;
            return Some(name.trim_end_matches('{').to_string());
        }
    }
    None
}

/// Generate a type alias
fn generate_alias(alias: &protocol_squisher_ir::AliasDef) -> String {
    let target_type = crate::mapping::PyO3Type::from_ir(&alias.target);
    format!(
        "/// Type alias: {}\npub type {} = {};\n",
        alias.name,
        alias.name,
        target_type.rust_type()
    )
}

/// Generate a newtype wrapper
fn generate_newtype(newtype: &protocol_squisher_ir::NewtypeDef) -> String {
    let inner_type = crate::mapping::PyO3Type::from_ir(&newtype.inner);
    let mut code = String::new();

    code.push_str("#[pyclass]\n");
    code.push_str("#[derive(Clone, Debug)]\n");
    code.push_str(&format!(
        "pub struct {}(pub {});\n\n",
        newtype.name,
        inner_type.rust_type()
    ));

    code.push_str("#[pymethods]\n");
    code.push_str(&format!("impl {} {{\n", newtype.name));
    code.push_str("    #[new]\n");
    code.push_str(&format!(
        "    pub fn new(value: {}) -> Self {{ Self(value) }}\n\n",
        inner_type.rust_type()
    ));
    code.push_str("    #[getter]\n");
    code.push_str(&format!(
        "    pub fn value(&self) -> {} {{ self.0.clone() }}\n",
        inner_type.rust_type()
    ));
    code.push_str("}\n");

    code
}

/// Generate a union wrapper.
///
/// Unions are represented as validated JSON payload strings for now, which keeps
/// the generated module usable while preserving opaque union semantics.
fn generate_union(union_def: &protocol_squisher_ir::UnionDef) -> String {
    let mut code = String::new();

    code.push_str("#[pyclass]\n");
    code.push_str("#[derive(Clone, Debug)]\n");
    code.push_str(&format!("pub struct {} {{\n", union_def.name));
    code.push_str("    pub raw_json: String,\n");
    code.push_str("}\n\n");

    code.push_str("#[pymethods]\n");
    code.push_str(&format!("impl {} {{\n", union_def.name));
    code.push_str("    #[new]\n");
    code.push_str("    pub fn new(raw_json: String) -> pyo3::PyResult<Self> {\n");
    code.push_str(
        "        serde_json::from_str::<serde_json::Value>(&raw_json)\n            .map_err(|e| pyo3::exceptions::PyValueError::new_err(e.to_string()))?;\n",
    );
    code.push_str("        Ok(Self { raw_json })\n");
    code.push_str("    }\n\n");
    code.push_str("    #[getter]\n");
    code.push_str("    pub fn raw_json(&self) -> String {\n");
    code.push_str("        self.raw_json.clone()\n");
    code.push_str("    }\n");
    code.push_str("}\n");

    code
}

/// Generate Python type stubs (.pyi content)
fn generate_python_stubs(schema: &IrSchema, types: &[String]) -> String {
    let mut stub = String::new();

    stub.push_str("# Generated by protocol-squisher-pyo3-codegen\n");
    stub.push_str("from typing import Any, Optional, Dict, List, Set, Tuple\n\n");

    for type_name in types {
        if let Some(type_def) = schema.types.get(type_name) {
            match type_def {
                TypeDef::Struct(s) => {
                    stub.push_str(&generate_struct_stub(s));
                },
                TypeDef::Enum(e) => {
                    stub.push_str(&generate_enum_stub(e));
                },
                TypeDef::Alias(a) => {
                    let target = crate::mapping::PyO3Type::from_ir(&a.target);
                    stub.push_str(&format!("{} = {}\n\n", a.name, target.python_annotation()));
                },
                TypeDef::Newtype(n) => {
                    stub.push_str(&generate_newtype_stub(n));
                },
                TypeDef::Union(u) => {
                    stub.push_str(&generate_union_stub(u));
                },
            }
        }
    }

    stub
}

/// Generate Python stub for a struct
fn generate_struct_stub(s: &protocol_squisher_ir::StructDef) -> String {
    let mut stub = String::new();

    stub.push_str(&format!("class {}:\n", s.name));

    // Properties
    for field in &s.fields {
        let pyo3_type = crate::mapping::PyO3Type::from_ir(&field.ty);
        let type_str = if field.optional {
            format!("{} | None", pyo3_type.python_annotation())
        } else {
            pyo3_type.python_annotation()
        };
        stub.push_str(&format!("    {}: {}\n", field.name, type_str));
    }

    // __init__
    let params: Vec<String> = s
        .fields
        .iter()
        .map(|f| {
            let pyo3_type = crate::mapping::PyO3Type::from_ir(&f.ty);
            if f.optional {
                format!(
                    "{}: {} | None = None",
                    f.name,
                    pyo3_type.python_annotation()
                )
            } else {
                format!("{}: {}", f.name, pyo3_type.python_annotation())
            }
        })
        .collect();
    stub.push_str(&format!(
        "    def __init__(self, {}) -> None: ...\n",
        params.join(", ")
    ));

    // Methods
    stub.push_str("    def __repr__(self) -> str: ...\n");
    stub.push_str("    def to_dict(self) -> Dict[str, Any]: ...\n");
    stub.push_str(&format!(
        "    @staticmethod\n    def from_dict(d: Dict[str, Any]) -> {}: ...\n",
        s.name
    ));
    stub.push_str("    def to_json(self) -> str: ...\n");
    stub.push_str(&format!(
        "    @staticmethod\n    def from_json(s: str) -> {}: ...\n\n",
        s.name
    ));

    stub
}

/// Generate Python stub for an enum
fn generate_enum_stub(e: &protocol_squisher_ir::EnumDef) -> String {
    let mut stub = String::new();

    let is_simple = e.variants.iter().all(|v| v.payload.is_none());

    stub.push_str(&format!("class {}:\n", e.name));

    if is_simple {
        // Simple enum - class attributes
        for variant in &e.variants {
            stub.push_str(&format!(
                "    {}: {}\n",
                variant.name.to_lowercase(),
                e.name
            ));
        }
        stub.push_str("    @property\n    def name(self) -> str: ...\n");
        stub.push_str("    @property\n    def value(self) -> int: ...\n");
    } else {
        // Complex enum - constructor methods
        for variant in &e.variants {
            match &variant.payload {
                None => {
                    stub.push_str(&format!(
                        "    @staticmethod\n    def {}() -> {}: ...\n",
                        variant.name.to_lowercase(),
                        e.name
                    ));
                },
                Some(protocol_squisher_ir::VariantPayload::Tuple(types)) => {
                    let params: Vec<String> = types
                        .iter()
                        .enumerate()
                        .map(|(i, t)| {
                            format!(
                                "v{}: {}",
                                i,
                                crate::mapping::PyO3Type::from_ir(t).python_annotation()
                            )
                        })
                        .collect();
                    stub.push_str(&format!(
                        "    @staticmethod\n    def {}({}) -> {}: ...\n",
                        variant.name.to_lowercase(),
                        params.join(", "),
                        e.name
                    ));
                },
                Some(protocol_squisher_ir::VariantPayload::Struct(fields)) => {
                    let params: Vec<String> = fields
                        .iter()
                        .map(|f| {
                            format!(
                                "{}: {}",
                                f.name,
                                crate::mapping::PyO3Type::from_ir(&f.ty).python_annotation()
                            )
                        })
                        .collect();
                    stub.push_str(&format!(
                        "    @staticmethod\n    def {}({}) -> {}: ...\n",
                        variant.name.to_lowercase(),
                        params.join(", "),
                        e.name
                    ));
                },
            }

            // is_* method
            stub.push_str(&format!(
                "    def is_{}(self) -> bool: ...\n",
                variant.name.to_lowercase()
            ));
        }
    }

    stub.push_str("    def __repr__(self) -> str: ...\n");
    stub.push_str("    def to_dict(self) -> Dict[str, Any]: ...\n");
    stub.push_str("    def to_json(self) -> str: ...\n");
    stub.push_str(&format!(
        "    @staticmethod\n    def from_json(s: str) -> {}: ...\n\n",
        e.name
    ));

    stub
}

/// Generate Python stub for a newtype
fn generate_newtype_stub(n: &protocol_squisher_ir::NewtypeDef) -> String {
    let inner = crate::mapping::PyO3Type::from_ir(&n.inner);
    let mut stub = String::new();

    stub.push_str(&format!("class {}:\n", n.name));
    stub.push_str(&format!(
        "    def __init__(self, value: {}) -> None: ...\n",
        inner.python_annotation()
    ));
    stub.push_str(&format!(
        "    @property\n    def value(self) -> {}: ...\n\n",
        inner.python_annotation()
    ));

    stub
}

/// Generate Python stub for a union wrapper.
fn generate_union_stub(u: &protocol_squisher_ir::UnionDef) -> String {
    let mut stub = String::new();
    stub.push_str(&format!("class {}:\n", u.name));
    stub.push_str("    raw_json: str\n");
    stub.push_str("    def __init__(self, raw_json: str) -> None: ...\n");
    stub.push_str("    def raw_json(self) -> str: ...\n\n");
    stub
}

#[cfg(test)]
mod tests {
    use super::*;
    use protocol_squisher_ir::{
        FieldDef, FieldMetadata, IrType, PrimitiveType, StructDef, TypeMetadata,
    };

    #[test]
    fn test_generate_simple_module() {
        let mut schema = IrSchema::new("test", "test");
        schema.add_type(
            "User".to_string(),
            TypeDef::Struct(StructDef {
                name: "User".to_string(),
                fields: vec![
                    FieldDef {
                        name: "id".to_string(),
                        ty: IrType::Primitive(PrimitiveType::I64),
                        optional: false,
                        constraints: vec![],
                        metadata: FieldMetadata::default(),
                    },
                    FieldDef {
                        name: "name".to_string(),
                        ty: IrType::Primitive(PrimitiveType::String),
                        optional: false,
                        constraints: vec![],
                        metadata: FieldMetadata::default(),
                    },
                ],
                metadata: TypeMetadata::default(),
            }),
        );

        let config = ModuleGenConfig::new("test_module");
        let result = generate_module(&schema, &config);

        assert!(result.rust_code.contains("pub struct User"));
        assert!(result.rust_code.contains("#[pymodule]"));
        assert!(result.rust_code.contains("m.add_class::<User>()"));
        assert!(result.generated_types.contains(&"User".to_string()));
    }

    #[test]
    fn test_generate_stubs() {
        let mut schema = IrSchema::new("test", "test");
        schema.add_type(
            "Config".to_string(),
            TypeDef::Struct(StructDef {
                name: "Config".to_string(),
                fields: vec![FieldDef {
                    name: "port".to_string(),
                    ty: IrType::Primitive(PrimitiveType::I32),
                    optional: false,
                    constraints: vec![],
                    metadata: FieldMetadata::default(),
                }],
                metadata: TypeMetadata::default(),
            }),
        );

        let config = ModuleGenConfig::new("test");
        let result = generate_module(&schema, &config);

        let stub = result.python_stub.unwrap();
        assert!(stub.contains("class Config:"));
        assert!(stub.contains("port: int"));
        assert!(stub.contains("def __init__"));
    }

    #[test]
    fn test_extract_type_name() {
        assert_eq!(
            extract_type_name("pub struct User {"),
            Some("User".to_string())
        );
        assert_eq!(
            extract_type_name("pub enum Status {"),
            Some("Status".to_string())
        );
        assert_eq!(extract_type_name("// comment"), None);
    }
}
