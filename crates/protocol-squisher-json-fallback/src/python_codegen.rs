// SPDX-License-Identifier: PMPL-1.0
// SPDX-FileCopyrightText: 2025 hyperpolymath

//! Python code generation for JSON fallback transport

use crate::FallbackConfig;
use protocol_squisher_ir::{
    ContainerType, EnumDef, FieldDef, IrSchema, IrType, PrimitiveType, SpecialType,
    StructDef, TagStyle, TypeDef, TypeId, VariantPayload,
};

/// Generate Python code for JSON serialization/deserialization
pub fn generate_python_fallback(
    schema: &IrSchema,
    type_ids: &[TypeId],
    config: &FallbackConfig,
) -> String {
    let mut code = String::new();

    // Header and imports
    code.push_str(&format!(
        r#"# SPDX-License-Identifier: PMPL-1.0
# Generated by protocol-squisher JSON fallback
# Module: {}

from __future__ import annotations
import json
from dataclasses import dataclass, field, asdict
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple, Union

"#,
        config.module_name
    ));

    // Generate type definitions
    for type_id in type_ids {
        if let Some(type_def) = schema.types.get(type_id) {
            code.push_str(&generate_type_def(type_def, config));
            code.push('\n');
        }
    }

    // Generate transport functions
    code.push_str(&generate_transport_functions(type_ids, config));

    code
}

fn generate_type_def(type_def: &TypeDef, config: &FallbackConfig) -> String {
    match type_def {
        TypeDef::Struct(s) => generate_struct(s, config),
        TypeDef::Enum(e) => generate_enum(e, config),
        TypeDef::Alias(a) => format!(
            "{} = {}\n",
            a.name,
            ir_type_to_python(&a.target, config.python_type_hints)
        ),
        TypeDef::Newtype(n) => generate_newtype(&n.name, &n.inner, config),
        TypeDef::Union(u) => generate_union(&u.name, &u.variants, config),
    }
}

fn generate_struct(s: &StructDef, config: &FallbackConfig) -> String {
    let mut code = String::new();

    code.push_str("@dataclass\n");
    code.push_str(&format!("class {}:\n", s.name));

    if s.fields.is_empty() {
        code.push_str("    pass\n");
        return code;
    }

    // Separate required and optional fields (required first)
    let (required, optional): (Vec<_>, Vec<_>) = s
        .fields
        .iter()
        .partition(|f| !f.optional && f.metadata.default.is_none());

    for field in required {
        code.push_str(&generate_field(field, config));
    }

    for field in optional {
        code.push_str(&generate_field(field, config));
    }

    // Add from_dict class method
    code.push_str("\n    @classmethod\n");
    code.push_str(&format!(
        "    def from_dict(cls, data: Dict[str, Any]) -> '{}':\n",
        s.name
    ));
    code.push_str("        return cls(\n");

    for field in &s.fields {
        if field.optional || field.metadata.default.is_some() {
            code.push_str(&format!(
                "            {}=data.get('{}'),\n",
                field.name, field.name
            ));
        } else {
            code.push_str(&format!(
                "            {}=data['{}'],\n",
                field.name, field.name
            ));
        }
    }

    code.push_str("        )\n");

    // Add to_dict method
    code.push_str("\n    def to_dict(self) -> Dict[str, Any]:\n");
    code.push_str("        result = asdict(self)\n");
    code.push_str("        # Remove None values for optional fields\n");
    code.push_str("        return {k: v for k, v in result.items() if v is not None}\n");

    code
}

fn generate_field(field: &FieldDef, config: &FallbackConfig) -> String {
    let python_type = ir_type_to_python(&field.ty, config.python_type_hints);

    let type_hint = if field.optional
        && !matches!(&field.ty, IrType::Container(ContainerType::Option(_)))
    {
        format!("Optional[{}]", python_type)
    } else {
        python_type
    };

    if field.optional || field.metadata.default.is_some() {
        let default_val = field
            .metadata
            .default
            .as_ref()
            .map(|d| json_value_to_python(d))
            .unwrap_or_else(|| "None".to_string());
        format!("    {}: {} = {}\n", field.name, type_hint, default_val)
    } else {
        format!("    {}: {}\n", field.name, type_hint)
    }
}

fn json_value_to_python(value: &serde_json::Value) -> String {
    match value {
        serde_json::Value::Null => "None".to_string(),
        serde_json::Value::Bool(b) => if *b { "True" } else { "False" }.to_string(),
        serde_json::Value::Number(n) => n.to_string(),
        serde_json::Value::String(s) => format!("'{}'", s.replace('\'', "\\'")),
        serde_json::Value::Array(arr) => {
            let items: Vec<String> = arr.iter().map(json_value_to_python).collect();
            format!("[{}]", items.join(", "))
        }
        serde_json::Value::Object(obj) => {
            let items: Vec<String> = obj
                .iter()
                .map(|(k, v)| format!("'{}': {}", k, json_value_to_python(v)))
                .collect();
            format!("{{{}}}", items.join(", "))
        }
    }
}

fn generate_enum(e: &EnumDef, config: &FallbackConfig) -> String {
    let mut code = String::new();

    // Check if this is a simple enum (no payloads)
    let is_simple = e.variants.iter().all(|v| v.payload.is_none());

    if is_simple {
        // Generate as Python Enum
        code.push_str(&format!("class {}(str, Enum):\n", e.name));
        for variant in &e.variants {
            let value = to_snake_case(&variant.name).to_uppercase();
            code.push_str(&format!("    {} = '{}'\n", variant.name, value));
        }
    } else {
        // Generate as dataclass with discriminated union
        code.push_str(&format!("# Tagged union: {}\n", e.name));

        // Generate variant classes
        for variant in &e.variants {
            match &variant.payload {
                None => {
                    code.push_str("@dataclass\n");
                    code.push_str(&format!("class {}{}:\n", e.name, variant.name));
                    code.push_str(&format!("    tag: str = '{}'\n", variant.name));
                    code.push('\n');
                }
                Some(VariantPayload::Tuple(types)) => {
                    code.push_str("@dataclass\n");
                    code.push_str(&format!("class {}{}:\n", e.name, variant.name));
                    if types.len() == 1 {
                        code.push_str(&format!(
                            "    value: {}\n",
                            ir_type_to_python(&types[0], config.python_type_hints)
                        ));
                    } else {
                        for (i, t) in types.iter().enumerate() {
                            code.push_str(&format!(
                                "    value_{}: {}\n",
                                i,
                                ir_type_to_python(t, config.python_type_hints)
                            ));
                        }
                    }
                    code.push_str(&format!("    tag: str = '{}'\n", variant.name));
                    code.push('\n');
                }
                Some(VariantPayload::Struct(fields)) => {
                    code.push_str("@dataclass\n");
                    code.push_str(&format!("class {}{}:\n", e.name, variant.name));
                    for field in fields {
                        code.push_str(&format!(
                            "    {}: {}\n",
                            field.name,
                            ir_type_to_python(&field.ty, config.python_type_hints)
                        ));
                    }
                    code.push_str(&format!("    tag: str = '{}'\n", variant.name));
                    code.push('\n');
                }
            }
        }

        // Generate union type alias
        let variant_types: Vec<String> = e
            .variants
            .iter()
            .map(|v| format!("{}{}", e.name, v.name))
            .collect();
        code.push_str(&format!(
            "{} = Union[{}]\n",
            e.name,
            variant_types.join(", ")
        ));

        // Generate parser function
        code.push_str(&format!(
            "\ndef parse_{}(data: Dict[str, Any]) -> {}:\n",
            to_snake_case(&e.name),
            e.name
        ));

        let tag_field = match &e.tag_style {
            TagStyle::External => "type",
            TagStyle::Internal { tag_field } => tag_field,
            TagStyle::Adjacent { tag_field, .. } => tag_field,
            TagStyle::Untagged => "type",
        };

        code.push_str(&format!("    tag = data.get('{}')\n", tag_field));

        for variant in &e.variants {
            code.push_str(&format!("    if tag == '{}':\n", variant.name));
            match &variant.payload {
                None => {
                    code.push_str(&format!("        return {}{}()\n", e.name, variant.name));
                }
                Some(VariantPayload::Tuple(types)) => {
                    let content_field = match &e.tag_style {
                        TagStyle::Adjacent { content_field, .. } => content_field.as_str(),
                        _ => "value",
                    };
                    if types.len() == 1 {
                        code.push_str(&format!(
                            "        return {}{}(value=data.get('{}'))\n",
                            e.name, variant.name, content_field
                        ));
                    } else {
                        code.push_str(&format!(
                            "        return {}{}(",
                            e.name, variant.name
                        ));
                        for i in 0..types.len() {
                            code.push_str(&format!("value_{}=data.get('value_{}'), ", i, i));
                        }
                        code.push_str(")\n");
                    }
                }
                Some(VariantPayload::Struct(fields)) => {
                    code.push_str(&format!("        return {}{}(\n", e.name, variant.name));
                    for field in fields {
                        code.push_str(&format!(
                            "            {}=data.get('{}'),\n",
                            field.name, field.name
                        ));
                    }
                    code.push_str("        )\n");
                }
            }
        }

        code.push_str(&format!(
            "    raise ValueError(f'Unknown {} variant: {{tag}}')\n",
            e.name
        ));
    }

    code
}

fn generate_newtype(name: &str, inner: &IrType, config: &FallbackConfig) -> String {
    format!(
        "@dataclass\nclass {}:\n    value: {}\n",
        name,
        ir_type_to_python(inner, config.python_type_hints)
    )
}

fn generate_union(name: &str, variants: &[IrType], config: &FallbackConfig) -> String {
    let types: Vec<String> = variants
        .iter()
        .map(|v| ir_type_to_python(v, config.python_type_hints))
        .collect();
    format!("{} = Union[{}]\n", name, types.join(", "))
}

fn ir_type_to_python(ir_type: &IrType, type_hints: bool) -> String {
    if !type_hints {
        return "Any".to_string();
    }

    match ir_type {
        IrType::Primitive(p) => primitive_to_python(p),
        IrType::Container(c) => container_to_python(c, type_hints),
        IrType::Reference(type_id) => format!("'{}'", type_id),
        IrType::Special(s) => special_to_python(s),
    }
}

fn container_to_python(c: &ContainerType, type_hints: bool) -> String {
    match c {
        ContainerType::Option(inner) => {
            format!("Optional[{}]", ir_type_to_python(inner, type_hints))
        }
        ContainerType::Vec(inner) => format!("List[{}]", ir_type_to_python(inner, type_hints)),
        ContainerType::Array(inner, _) => format!("List[{}]", ir_type_to_python(inner, type_hints)),
        ContainerType::Set(inner) => format!("Set[{}]", ir_type_to_python(inner, type_hints)),
        ContainerType::Map(key, value) => {
            format!(
                "Dict[{}, {}]",
                ir_type_to_python(key, type_hints),
                ir_type_to_python(value, type_hints)
            )
        }
        ContainerType::Tuple(elements) => {
            let types: Vec<String> = elements
                .iter()
                .map(|e| ir_type_to_python(e, type_hints))
                .collect();
            format!("Tuple[{}]", types.join(", "))
        }
        ContainerType::Result(ok, err) => {
            format!(
                "Union[{}, {}]",
                ir_type_to_python(ok, type_hints),
                ir_type_to_python(err, type_hints)
            )
        }
    }
}

fn primitive_to_python(p: &PrimitiveType) -> String {
    match p {
        PrimitiveType::Bool => "bool",
        PrimitiveType::I8
        | PrimitiveType::I16
        | PrimitiveType::I32
        | PrimitiveType::I64
        | PrimitiveType::I128 => "int",
        PrimitiveType::U8
        | PrimitiveType::U16
        | PrimitiveType::U32
        | PrimitiveType::U64
        | PrimitiveType::U128 => "int",
        PrimitiveType::F32 | PrimitiveType::F64 => "float",
        PrimitiveType::String | PrimitiveType::Char => "str",
        PrimitiveType::Bytes => "bytes",
        PrimitiveType::DateTime | PrimitiveType::Date | PrimitiveType::Time => "str",
        PrimitiveType::Duration => "str",
        PrimitiveType::Uuid => "str",
        PrimitiveType::Decimal | PrimitiveType::BigInt => "str",
    }
    .to_string()
}

fn special_to_python(s: &SpecialType) -> String {
    match s {
        SpecialType::Any | SpecialType::Json => "Any".to_string(),
        SpecialType::Unit => "None".to_string(),
        SpecialType::Never => "None".to_string(),
        SpecialType::Opaque(_) => "bytes".to_string(),
    }
}

fn generate_transport_functions(type_ids: &[TypeId], config: &FallbackConfig) -> String {
    let mut code = String::new();

    code.push_str("# === Transport Functions ===\n\n");

    for type_id in type_ids {
        let name = type_id;
        let snake_name = to_snake_case(name);

        // to_json function
        code.push_str(&format!(
            r#"def {}_to_json(value: {}) -> str:
    """Serialize {} to JSON string."""
    if hasattr(value, 'to_dict'):
        data = value.to_dict()
    else:
        data = asdict(value) if hasattr(value, '__dataclass_fields__') else value
    return json.dumps(data{})


"#,
            snake_name,
            name,
            name,
            if config.pretty_json { ", indent=2" } else { "" }
        ));

        // from_json function
        code.push_str(&format!(
            r#"def {}_from_json(json_str: str) -> {}:
    """Deserialize {} from JSON string."""
    data = json.loads(json_str)
    return {}.from_dict(data)


"#,
            snake_name, name, name, name
        ));

        // to_json_bytes function
        code.push_str(&format!(
            r#"def {}_to_json_bytes(value: {}) -> bytes:
    """Serialize {} to JSON bytes."""
    return {}_to_json(value).encode('utf-8')


"#,
            snake_name, name, name, snake_name
        ));

        // from_json_bytes function
        code.push_str(&format!(
            r#"def {}_from_json_bytes(data: bytes) -> {}:
    """Deserialize {} from JSON bytes."""
    return {}_from_json(data.decode('utf-8'))


"#,
            snake_name, name, name, snake_name
        ));
    }

    code
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_lowercase().next().unwrap());
        } else {
            result.push(c);
        }
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;
    use protocol_squisher_ir::*;

    #[test]
    fn test_primitive_to_python() {
        assert_eq!(primitive_to_python(&PrimitiveType::I32), "int");
        assert_eq!(primitive_to_python(&PrimitiveType::F64), "float");
        assert_eq!(primitive_to_python(&PrimitiveType::Bool), "bool");
        assert_eq!(primitive_to_python(&PrimitiveType::String), "str");
    }

    #[test]
    fn test_container_to_python() {
        assert_eq!(
            container_to_python(
                &ContainerType::Vec(Box::new(IrType::Primitive(PrimitiveType::String))),
                true
            ),
            "List[str]"
        );
        assert_eq!(
            container_to_python(
                &ContainerType::Option(Box::new(IrType::Primitive(PrimitiveType::I32))),
                true
            ),
            "Optional[int]"
        );
    }

    #[test]
    fn test_generate_struct() {
        let s = StructDef {
            name: "Point".to_string(),
            fields: vec![
                FieldDef {
                    name: "x".to_string(),
                    ty: IrType::Primitive(PrimitiveType::F64),
                    optional: false,
                    constraints: vec![],
                    metadata: FieldMetadata::default(),
                },
                FieldDef {
                    name: "y".to_string(),
                    ty: IrType::Primitive(PrimitiveType::F64),
                    optional: false,
                    constraints: vec![],
                    metadata: FieldMetadata::default(),
                },
            ],
            metadata: TypeMetadata::default(),
        };

        let config = FallbackConfig::default();
        let code = generate_struct(&s, &config);

        assert!(code.contains("@dataclass"));
        assert!(code.contains("class Point:"));
        assert!(code.contains("x: float"));
        assert!(code.contains("y: float"));
        assert!(code.contains("def from_dict"));
        assert!(code.contains("def to_dict"));
    }

    #[test]
    fn test_generate_simple_enum() {
        let e = EnumDef {
            name: "Color".to_string(),
            variants: vec![
                VariantDef {
                    name: "Red".to_string(),
                    payload: None,
                    metadata: VariantMetadata::default(),
                },
                VariantDef {
                    name: "Green".to_string(),
                    payload: None,
                    metadata: VariantMetadata::default(),
                },
                VariantDef {
                    name: "Blue".to_string(),
                    payload: None,
                    metadata: VariantMetadata::default(),
                },
            ],
            tag_style: TagStyle::External,
            metadata: TypeMetadata::default(),
        };

        let config = FallbackConfig::default();
        let code = generate_enum(&e, &config);

        assert!(code.contains("class Color(str, Enum):"));
        assert!(code.contains("Red = 'RED'"));
        assert!(code.contains("Green = 'GREEN'"));
        assert!(code.contains("Blue = 'BLUE'"));
    }

    #[test]
    fn test_to_snake_case() {
        assert_eq!(to_snake_case("User"), "user");
        assert_eq!(to_snake_case("OrderItem"), "order_item");
        assert_eq!(to_snake_case("HTTPRequest"), "h_t_t_p_request");
    }
}
