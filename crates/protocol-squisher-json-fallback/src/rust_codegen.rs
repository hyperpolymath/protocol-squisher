// SPDX-License-Identifier: PMPL-1.0-or-later
// SPDX-FileCopyrightText: 2025 Jonathan D.A. Jewell

//! Rust code generation for JSON fallback transport

use crate::FallbackConfig;
use protocol_squisher_ir::{
    ContainerType, EnumDef, FieldDef, IrSchema, IrType, PrimitiveType, SpecialType, StructDef,
    TagStyle, TypeDef, TypeId, VariantPayload,
};

/// Generate Rust code for JSON serialization/deserialization
pub fn generate_rust_fallback(
    schema: &IrSchema,
    type_ids: &[TypeId],
    config: &FallbackConfig,
) -> String {
    let mut code = String::new();

    // Header
    code.push_str(&format!(
        r#"// SPDX-License-Identifier: PMPL-1.0-or-later
// Generated by protocol-squisher JSON fallback
// Module: {}

use serde::{{Deserialize, Serialize}};

"#,
        config.module_name
    ));

    // Generate type definitions
    for type_id in type_ids {
        if let Some(type_def) = schema.types.get(type_id) {
            code.push_str(&generate_type_def(type_def, config));
            code.push('\n');
        }
    }

    // Generate transport functions
    code.push_str(&generate_transport_functions(type_ids, config));

    code
}

fn generate_type_def(type_def: &TypeDef, config: &FallbackConfig) -> String {
    match type_def {
        TypeDef::Struct(s) => generate_struct(s, config),
        TypeDef::Enum(e) => generate_enum(e, config),
        TypeDef::Alias(a) => format!("pub type {} = {};\n", a.name, ir_type_to_rust(&a.target)),
        TypeDef::Newtype(n) => format!(
            "#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct {}(pub {});\n",
            n.name,
            ir_type_to_rust(&n.inner)
        ),
        TypeDef::Union(u) => {
            // Generate as an untagged enum
            let variants: Vec<String> = u
                .variants
                .iter()
                .enumerate()
                .map(|(i, v)| format!("    Variant{}({})", i, ir_type_to_rust(v)))
                .collect();
            format!(
                "#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum {} {{\n{}\n}}\n",
                u.name,
                variants.join(",\n")
            )
        },
    }
}

fn generate_struct(s: &StructDef, _config: &FallbackConfig) -> String {
    let mut code = String::new();

    code.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
    code.push_str(&format!("pub struct {} {{\n", s.name));

    for field in &s.fields {
        code.push_str(&generate_field(field));
    }

    code.push_str("}\n");
    code
}

fn generate_field(field: &FieldDef) -> String {
    let rust_type =
        if field.optional && !matches!(&field.ty, IrType::Container(ContainerType::Option(_))) {
            format!("Option<{}>", ir_type_to_rust(&field.ty))
        } else {
            ir_type_to_rust(&field.ty)
        };

    let mut attrs = Vec::new();

    // Add skip_serializing_if for optional fields
    if field.optional {
        attrs.push("skip_serializing_if = \"Option::is_none\"".to_string());
    }

    // Add default for optional fields or if default is specified in metadata
    if field.optional || field.metadata.default.is_some() {
        attrs.push("default".to_string());
    }

    let attr_str = if attrs.is_empty() {
        String::new()
    } else {
        format!("    #[serde({})]\n", attrs.join(", "))
    };

    format!("{}    pub {}: {},\n", attr_str, field.name, rust_type)
}

fn generate_enum(e: &EnumDef, _config: &FallbackConfig) -> String {
    let mut code = String::new();

    code.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");

    // Add serde tag attributes
    match &e.tag_style {
        TagStyle::External => {},
        TagStyle::Internal { tag_field } => {
            code.push_str(&format!("#[serde(tag = \"{}\")]\n", tag_field));
        },
        TagStyle::Adjacent {
            tag_field,
            content_field,
        } => {
            code.push_str(&format!(
                "#[serde(tag = \"{}\", content = \"{}\")]\n",
                tag_field, content_field
            ));
        },
        TagStyle::Untagged => {
            code.push_str("#[serde(untagged)]\n");
        },
    }

    code.push_str(&format!("pub enum {} {{\n", e.name));

    for variant in &e.variants {
        code.push_str(&generate_variant(variant));
    }

    code.push_str("}\n");
    code
}

fn generate_variant(variant: &protocol_squisher_ir::VariantDef) -> String {
    match &variant.payload {
        None => format!("    {},\n", variant.name),
        Some(VariantPayload::Tuple(types)) => {
            if types.len() == 1 {
                format!("    {}({}),\n", variant.name, ir_type_to_rust(&types[0]))
            } else {
                let type_strs: Vec<String> = types.iter().map(ir_type_to_rust).collect();
                format!("    {}({}),\n", variant.name, type_strs.join(", "))
            }
        },
        Some(VariantPayload::Struct(fields)) => {
            let mut code = format!("    {} {{\n", variant.name);
            for field in fields {
                code.push_str(&format!(
                    "        {}: {},\n",
                    field.name,
                    ir_type_to_rust(&field.ty)
                ));
            }
            code.push_str("    },\n");
            code
        },
    }
}

fn ir_type_to_rust(ir_type: &IrType) -> String {
    match ir_type {
        IrType::Primitive(p) => primitive_to_rust(p),
        IrType::Container(c) => container_to_rust(c),
        IrType::Reference(type_id) => type_id.clone(),
        IrType::Special(s) => special_to_rust(s),
    }
}

fn container_to_rust(c: &ContainerType) -> String {
    match c {
        ContainerType::Option(inner) => format!("Option<{}>", ir_type_to_rust(inner)),
        ContainerType::Vec(inner) => format!("Vec<{}>", ir_type_to_rust(inner)),
        ContainerType::Array(inner, size) => format!("[{}; {}]", ir_type_to_rust(inner), size),
        ContainerType::Set(inner) => {
            format!("std::collections::HashSet<{}>", ir_type_to_rust(inner))
        },
        ContainerType::Map(key, value) => {
            format!(
                "std::collections::HashMap<{}, {}>",
                ir_type_to_rust(key),
                ir_type_to_rust(value)
            )
        },
        ContainerType::Tuple(elements) => {
            let types: Vec<String> = elements.iter().map(ir_type_to_rust).collect();
            format!("({})", types.join(", "))
        },
        ContainerType::Result(ok, err) => {
            format!("Result<{}, {}>", ir_type_to_rust(ok), ir_type_to_rust(err))
        },
    }
}

fn primitive_to_rust(p: &PrimitiveType) -> String {
    match p {
        PrimitiveType::Bool => "bool",
        PrimitiveType::I8 => "i8",
        PrimitiveType::I16 => "i16",
        PrimitiveType::I32 => "i32",
        PrimitiveType::I64 => "i64",
        PrimitiveType::I128 => "i128",
        PrimitiveType::U8 => "u8",
        PrimitiveType::U16 => "u16",
        PrimitiveType::U32 => "u32",
        PrimitiveType::U64 => "u64",
        PrimitiveType::U128 => "u128",
        PrimitiveType::F32 => "f32",
        PrimitiveType::F64 => "f64",
        PrimitiveType::String => "String",
        PrimitiveType::Char => "char",
        PrimitiveType::Bytes => "Vec<u8>",
        PrimitiveType::DateTime => "String", // Use string for ISO 8601
        PrimitiveType::Date => "String",
        PrimitiveType::Time => "String",
        PrimitiveType::Duration => "String",
        PrimitiveType::Uuid => "String", // Use string for UUID
        PrimitiveType::Decimal => "String",
        PrimitiveType::BigInt => "String",
    }
    .to_string()
}

fn special_to_rust(s: &SpecialType) -> String {
    match s {
        SpecialType::Any | SpecialType::Json => "serde_json::Value".to_string(),
        SpecialType::Unit => "()".to_string(),
        SpecialType::Never => "std::convert::Infallible".to_string(),
        SpecialType::Opaque(hint) => format!("Vec<u8> /* opaque: {} */", hint),
    }
}

fn generate_transport_functions(type_ids: &[TypeId], config: &FallbackConfig) -> String {
    let mut code = String::new();

    code.push_str("// === Transport Functions ===\n\n");

    for type_id in type_ids {
        let name = type_id;
        let snake_name = to_snake_case(name);

        // to_json function
        code.push_str(&format!(
            r#"/// Serialize {} to JSON string
pub fn {}_to_json(value: &{}) -> Result<String, serde_json::Error> {{
    {}
}}

"#,
            name,
            snake_name,
            name,
            if config.pretty_json {
                "serde_json::to_string_pretty(value)"
            } else {
                "serde_json::to_string(value)"
            }
        ));

        // from_json function
        code.push_str(&format!(
            r#"/// Deserialize {} from JSON string
pub fn {}_from_json(json: &str) -> Result<{}, serde_json::Error> {{
    serde_json::from_str(json)
}}

"#,
            name, snake_name, name
        ));

        // to_json_bytes function
        code.push_str(&format!(
            r#"/// Serialize {} to JSON bytes
pub fn {}_to_json_bytes(value: &{}) -> Result<Vec<u8>, serde_json::Error> {{
    serde_json::to_vec{}(value)
}}

"#,
            name,
            snake_name,
            name,
            if config.pretty_json { "_pretty" } else { "" }
        ));

        // from_json_bytes function
        code.push_str(&format!(
            r#"/// Deserialize {} from JSON bytes
pub fn {}_from_json_bytes(bytes: &[u8]) -> Result<{}, serde_json::Error> {{
    serde_json::from_slice(bytes)
}}

"#,
            name, snake_name, name
        ));
    }

    code
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            for lower in c.to_lowercase() {
                result.push(lower);
            }
        } else {
            result.push(c);
        }
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;
    use protocol_squisher_ir::*;

    #[test]
    fn test_primitive_to_rust() {
        assert_eq!(primitive_to_rust(&PrimitiveType::I32), "i32");
        assert_eq!(primitive_to_rust(&PrimitiveType::F64), "f64");
        assert_eq!(primitive_to_rust(&PrimitiveType::Bool), "bool");
        assert_eq!(primitive_to_rust(&PrimitiveType::String), "String");
    }

    #[test]
    fn test_container_to_rust() {
        assert_eq!(
            container_to_rust(&ContainerType::Vec(Box::new(IrType::Primitive(
                PrimitiveType::String
            )))),
            "Vec<String>"
        );
        assert_eq!(
            container_to_rust(&ContainerType::Option(Box::new(IrType::Primitive(
                PrimitiveType::I32
            )))),
            "Option<i32>"
        );
    }

    #[test]
    fn test_to_snake_case() {
        assert_eq!(to_snake_case("User"), "user");
        assert_eq!(to_snake_case("OrderItem"), "order_item");
        assert_eq!(to_snake_case("XMLParser"), "x_m_l_parser");
    }

    #[test]
    fn test_generate_struct() {
        let s = StructDef {
            name: "Point".to_string(),
            fields: vec![
                FieldDef {
                    name: "x".to_string(),
                    ty: IrType::Primitive(PrimitiveType::F64),
                    optional: false,
                    constraints: vec![],
                    metadata: FieldMetadata::default(),
                },
                FieldDef {
                    name: "y".to_string(),
                    ty: IrType::Primitive(PrimitiveType::F64),
                    optional: false,
                    constraints: vec![],
                    metadata: FieldMetadata::default(),
                },
            ],
            metadata: TypeMetadata::default(),
        };

        let config = FallbackConfig::default();
        let code = generate_struct(&s, &config);

        assert!(code.contains("#[derive(Debug, Clone, Serialize, Deserialize)]"));
        assert!(code.contains("pub struct Point"));
        assert!(code.contains("pub x: f64"));
        assert!(code.contains("pub y: f64"));
    }

    #[test]
    fn test_generate_enum_external_tag() {
        let e = EnumDef {
            name: "Color".to_string(),
            variants: vec![
                VariantDef {
                    name: "Red".to_string(),
                    payload: None,
                    metadata: VariantMetadata::default(),
                },
                VariantDef {
                    name: "Green".to_string(),
                    payload: None,
                    metadata: VariantMetadata::default(),
                },
                VariantDef {
                    name: "Rgb".to_string(),
                    payload: Some(VariantPayload::Tuple(vec![
                        IrType::Primitive(PrimitiveType::U8),
                        IrType::Primitive(PrimitiveType::U8),
                        IrType::Primitive(PrimitiveType::U8),
                    ])),
                    metadata: VariantMetadata::default(),
                },
            ],
            tag_style: TagStyle::External,
            metadata: TypeMetadata::default(),
        };

        let config = FallbackConfig::default();
        let code = generate_enum(&e, &config);

        assert!(code.contains("pub enum Color"));
        assert!(code.contains("Red,"));
        assert!(code.contains("Green,"));
        assert!(code.contains("Rgb(u8, u8, u8)"));
    }

    #[test]
    fn test_generate_enum_internal_tag() {
        let e = EnumDef {
            name: "Message".to_string(),
            variants: vec![VariantDef {
                name: "Text".to_string(),
                payload: Some(VariantPayload::Tuple(vec![IrType::Primitive(
                    PrimitiveType::String,
                )])),
                metadata: VariantMetadata::default(),
            }],
            tag_style: TagStyle::Internal {
                tag_field: "type".to_string(),
            },
            metadata: TypeMetadata::default(),
        };

        let config = FallbackConfig::default();
        let code = generate_enum(&e, &config);

        assert!(code.contains("#[serde(tag = \"type\")]"));
    }
}
