image:https://img.shields.io/badge/License-PMPL--1.0-blue.svg[License: PMPL-1.0,link="https://github.com/hyperpolymath/palimpsest-license"]

// SPDX-License-Identifier: PMPL-1.0-or-later
// SPDX-FileCopyrightText: 2025 hyperpolymath
= Protocol Squisher



:toc: macro
:toclevels: 3
:icons: font

[.lead]
**Universal protocol interoperability through automatic adapter synthesis.**

[NOTE]
====
**Status:** ✅ **MVP Complete** (100%)

- 312 tests passing (ephapax IR + analyzers + codegen + optimizer + property tests)
- Rust ↔ Python fully working (Concorde, Business, Economy, Wheelbarrow classes)
- Formal verification (4 theorems proven in Agda, cross-validated in Lean)
- Comprehensive documentation (CLI guide, optimization guide, transport classes reference)
- Ready for real-world use and Phase 2 format expansion

**Next:** Public launch, gather feedback, expand to Cap'n Proto/Protobuf/Thrift/Avro
====

____
*The Invariant:* If it compiles, it carries.

Every data serialization format can talk to every other format. Always. Even if slow. Even if lossy. But it *will* transport.
____

toc::[]

== The Problem

You have a Factor serialization library. Your colleague has a Cap'n Proto service. You need them to talk.

**Current options:**

1. Write a manual adapter (hours/days of work)
2. Use JSON as lingua franca (slow, lossy, manual)
3. Rewrite one side (expensive, political nightmare)
4. Give up

**What if there was another way?**

== The Solution

Protocol Squisher analyzes two incompatible serialization formats and synthesizes the *minimum viable adapter* that guarantees transport.

[source,bash]
----
$ protocol-squish analyze factor-schema.factor capnproto-schema.capnp

Compatibility Analysis:
  Transport Class: Wheelbarrow (47% type fidelity)
  Estimated Overhead: -60% performance
  Losses: circular references, some type precision

TRANSPORT VIABLE: ✓

$ protocol-squish generate --output ./adapter/

Generated:
  ✓ adapter.rs (1,247 lines)
  ✓ tests.rs (894 lines)
  ✓ README.md

Adapter guarantees:
  [PROVEN] All data that enters will exit
  [PROVEN] No undefined behavior
  [DOCUMENTED] Type conversions and losses
----

== Transport Classes

Protocol Squisher classifies every format pair into transport classes:

[cols="1,2,2",options="header"]
|===
|Class |Description |Example

|**Concorde**
|Zero-copy, full fidelity, maximum performance
|serde ↔ serde (same Rust types)

|**Business Class**
|Minor overhead, full fidelity
|Protobuf ↔ Thrift (similar models)

|**Economy**
|Moderate overhead, documented losses
|JSON ↔ MessagePack

|**Wheelbarrow**
|High overhead, significant losses, but *it works*
|Factor ↔ Cap'n Proto
|===

== The Invariant

**Every adapter we generate maintains this invariant:**

____
For any valid input `x` in format A, there exists a valid output `y` in format B such that `squish(x) = y`.

If A cannot represent some value from B, we document the loss *before* you use the adapter.
____

We achieve this through:

1. **Canonical IR**: Every format maps to our intermediate representation
2. **Compatibility Analysis**: Before generating, we prove transport is possible
3. **JSON Fallback**: When all else fails, JSON becomes the wheelbarrow
4. **Property-Based Testing**: Exhaustive verification of adapter correctness

== Quick Start

[source,bash]
----
# Install
cargo install --path crates/protocol-squisher-cli

# Check Rust ↔ Python compatibility
protocol-squisher check \
  --rust examples/zero-copy-demo/src/lib.rs \
  --python examples/zero-copy-demo/models.py

# Get optimization suggestions
protocol-squisher optimize --rust src/lib.rs --python models.py

# Generate PyO3 bindings
protocol-squisher generate \
  --rust src/lib.rs \
  --python models.py \
  --output generated/ \
  --stubs
----

**See link:docs/CLI-GUIDE.adoc[CLI Usage Guide] for complete documentation and workflows.**

== Supported Formats

=== Currently Supported
- Rust (serde)
- Python (Pydantic)
- JSON

=== Coming Soon
- Cap'n Proto
- Protobuf
- Thrift
- Avro
- MessagePack
- Factor

See link:ROADMAP.adoc[ROADMAP.adoc] for the full expansion plan.

== Documentation

**Getting Started:**
- link:docs/CLI-GUIDE.adoc[CLI Usage Guide] - Command reference and workflows (**start here**)
- link:examples/README.md[Example Projects] - Working examples with benchmarks
- link:docs/OPTIMIZATION-GUIDE.adoc[Optimization Guide] - How to achieve zero-copy transport
- link:docs/TRANSPORT-CLASSES.adoc[Transport Classes Reference] - Detailed theory and API

**Advanced:**
- link:proofs/README.adoc[Formal Proofs] - Theorem prover verification (ECHIDNA + Agda + Lean)
- link:ROADMAP.adoc[Roadmap] - Project roadmap and future plans
- link:GAUNTLET.adoc[The Gauntlet] - Hard problems we're solving
- link:docs/architecture.adoc[Architecture] - System architecture
- link:docs/ir-spec.adoc[IR Specification] - The intermediate representation

**Performance:**
- link:docs/BENCHMARK-QUICKSTART.md[Benchmark Quick Start] - Run benchmarks in 5 minutes (**start here**)
- link:benches/README.md[Benchmark Suite Documentation] - Comprehensive benchmark guide
- link:docs/BENCHMARK-RESULTS.md[Results Interpretation] - How to read and validate performance

== Contributing

We welcome contributions! See link:CONTRIBUTING.adoc[CONTRIBUTING.adoc].

**Especially valuable:**
- New format analyzers
- Real-world schema examples
- Edge cases that break the invariant
- Performance optimizations

== License

PMPL-1.0-or-later. See link:LICENSE[LICENSE].

== Acknowledgments

Inspired by the frustration of every polyglot developer who has ever had to bridge two serialization formats manually.
