// SPDX-License-Identifier: PMPL-1.0-or-later
// SPDX-FileCopyrightText: 2025 hyperpolymath
= Protocol Squisher Roadmap
:toc: macro
:toclevels: 3
:icons: font

[.lead]
**From concept to rethinking the world's data exchange**

[NOTE]
====
**Current Status:** ‚úÖ **Phase 2 Format Expansion Complete** (February 2026)

Phase 0 (Foundation) and Phase 1 (MVP) are 100% complete:
- ‚úÖ ephapax IR with Idris2 dependent types
- ‚úÖ Rust and Python analyzers (59 tests)
- ‚úÖ Compatibility engine with 4 transport classes
- ‚úÖ PyO3 code generation
- ‚úÖ JSON fallback (Wheelbarrow)
- ‚úÖ Optimizer with suggestions
- ‚úÖ CLI tool (analyze, check, optimize, generate)
- ‚úÖ Property-based tests (64 tests)
- ‚úÖ Formal verification (Agda + Lean proofs)
- ‚úÖ Comprehensive documentation

**Phase 2 (Format Expansion):**
- ‚úÖ 11 protocol analyzers implemented (Rust, Python, JSON Schema, Protobuf, Bebop, FlatBuffers, MessagePack, Avro, Cap'n Proto, Thrift, ReScript)
- ‚úÖ Diversity/squishability analysis across protocol families

**Now:** Public launch hardening and Phase 3 (real-world validation, synthesis, advanced features)
====

toc::[]

== Vision Horizon

=== The End State (3-5 years)

**"Any data format can talk to any other data format. Always."**

- 50+ serialization formats supported
- Formal verification for all adapters
- Security protocol bridging (TLS, Noise, WireGuard)
- FFI replacement for 80% of use cases
- Industry-standard interop layer
- Self-improving through continuous learning

=== The Inflection Point (1-2 years)

**"Python and Rust developers never write FFI code again"**

- Python ‚Üî Rust is production-ready
- 10+ major format pairs supported
- Empirical compatibility database from 10,000+ schemas
- Community contributions exceed core team
- First major company adopts for production

=== The MVP (3-6 months)

**"One working demo that proves the invariant"**

- Python (Pydantic) ‚Üî Rust (serde)
- JSON fallback guarantees transport
- Basic adapter generation
- Property-based test coverage
- Clear documentation of losses

== Phase 0: Foundation (Weeks 1-4)

**Goal:** Core infrastructure and IR design

=== Week 1: Canonical IR
- [x] Design intermediate representation
- [x] Implement type system (primitives, containers, composites)
- [x] Constraint representation
- [x] IR ‚Üî JSON serialization (for tooling)
- [x] Property-based tests for IR invariants

**Deliverable:** `protocol-squisher-ir` crate with comprehensive tests ‚úì **COMPLETE** (ephapax IR in Idris2 with dependent types)

=== Week 2: First Analyzer (Rust)
- [x] Parse Rust source files (`syn` crate)
- [x] Extract serde types
- [x] Convert to IR
- [x] Handle common patterns (Option, Vec, HashMap)
- [x] Test against real serde examples

**Deliverable:** `protocol-squisher-rust-analyzer` crate ‚úì **COMPLETE** (30 tests passing)

=== Week 3: Second Analyzer (Python)
- [x] Python introspection script for Pydantic
- [x] Parse introspection output in Rust
- [x] Convert to IR
- [x] Handle Python type hints
- [x] Test against real Pydantic models

**Deliverable:** `protocol-squisher-python-analyzer` crate ‚úì **COMPLETE** (29 tests passing)

=== Week 4: Compatibility Engine
- [x] IR comparison algorithm
- [x] Type compatibility rules
- [x] Classification (Concorde/Wheelbarrow/etc.)
- [x] Loss documentation
- [x] Performance estimation

**Deliverable:** `protocol-squisher-compat` crate with scoring system ‚úì **COMPLETE** (31 tests passing)

== Phase 1: Minimum Viable Demo (Weeks 5-12)

**Goal:** Python ‚Üî Rust adapter that always works

=== Weeks 5-6: JSON Fallback
- [x] JSON serialization for all IR types
- [x] Rust ‚Üí JSON ‚Üí Python path
- [x] Python ‚Üí JSON ‚Üí Rust path
- [x] Prove transport always succeeds
- [x] Benchmark overhead

**Deliverable:** The guaranteed wheelbarrow. Slow but unbreakable. ‚úì **COMPLETE** (20 tests passing)

=== Weeks 7-8: PyO3 Codegen
- [x] Generate PyO3 wrapper code
- [x] Handle type conversions
- [x] Error handling
- [x] Memory management
- [x] Generated code passes clippy/mypy

**Deliverable:** `protocol-squisher-pyo3-codegen` crate ‚úì **COMPLETE** (33 tests passing)

=== Weeks 9-10: Optimization Layer
- [x] Detect when zero-copy possible
- [x] Generate optimized paths
- [x] Benchmark against JSON fallback
- [x] Document when optimizations apply

**Deliverable:** Concorde-class adapters for compatible types ‚úì **COMPLETE** (34 tests passing)

=== Weeks 11-12: Polish & Demo
- [x] CLI tool (`protocol-squisher` binary)
- [x] End-to-end examples
- [x] Performance benchmarks
- [x] Documentation
- [x] HN launch post draft + runbook
- [ ] HN submission + day-1 response window

**Deliverable:** Public demo, first users üöß **IN PROGRESS** (CLI, examples, docs, and HN assets complete; external HN posting pending)

== Phase 2: Format Expansion (Months 4-6)

**Goal:** Support 10+ serialization formats

=== Priority Targets

[cols="1,1,1",options="header"]
|===
|Format Pair |Impact |Difficulty

|**Cap'n Proto ‚Üî Factor**
|FormDB use case, hard problem
|High (dynamic ‚Üî zero-copy)

|**Protobuf ‚Üî JSON**
|Massive existing need
|Low (well-understood)

|**Thrift ‚Üî Avro**
|Enterprise adoption
|Medium (both schema-based)

|**MessagePack ‚Üî serde**
|Rust ecosystem
|Low (similar models)

|**Excel ‚Üî Protobuf**
|Business world
|Medium (type inference)

|**GraphQL ‚Üî PostgreSQL**
|Web development
|Medium (schema translation)
|===

=== Continuous Learning System

- [x] Elixir OTP crawler for GitHub schemas
- [x] Parallel schema parsing
- [x] Empirical compatibility database
- [x] Pattern extraction
- [x] Feed patterns back to synthesis layer

**Deliverable:** Self-improving system (crawler + parser + empirical DB + synthesis-hint feedback loop)

== Phase 3: Advanced Features (Months 7-12)

=== Formal Verification
- [x] ECHIDNA theorem prover integration
- [x] Correctness proofs (Agda + Lean)
- [x] Exhaustive property testing
- [x] Fuzzing infrastructure
- [x] miniKanren adapter synthesis

**Status:** üöß **IN PROGRESS** - ECHIDNA integration complete with 4 core theorems proven in Agda/Lean, property tests (288/540 tests), ClusterFuzzLite configured

=== Security Protocol Support
- [x] TLS version bridging
- [x] Protocol family translation (TLS ‚Üî Noise)
- [x] Security property verification
- [x] Rejection of unsafe combinations

=== FFI Replacement
- [x] Function call bridging
- [x] Memory ownership semantics
- [x] Callback support
- [x] Performance competitive with manual FFI

=== Performance Optimization
- [x] Zero-copy where possible
- [x] SIMD for compatible types
- [x] Lazy deserialization
- [x] Streaming support

**Deliverable:** Production-grade system

== Phase 4: Ecosystem Growth (Year 2+)

=== Developer Experience
- [ ] IDE plugins (LSP for adapter previews)
- [ ] Interactive compatibility explorer
- [ ] Web playground
- [ ] Adapter marketplace

=== Enterprise Features
- [ ] Schema registry integration
- [ ] Version migration tools
- [ ] Audit logging
- [ ] Governance policies

=== Research Directions
- [ ] AI-assisted optimization
- [ ] Novel transformation primitives (cut, splice, reify)
- [ ] Distributed protocol squishing
- [ ] Hardware acceleration

== Success Metrics

=== MVP Success (Month 3)
- [ ] 1,000+ GitHub stars
- [ ] 10+ external contributors
- [ ] 100+ real-world schemas tested
- [ ] 0 invariant violations found

=== Inflection Point (Month 12)
- [ ] 10,000+ GitHub stars
- [ ] 100+ contributors
- [ ] 5+ companies using in production
- [ ] Featured in major tech publications

=== End State (Year 3+)
- [ ] De facto standard for polyglot systems
- [ ] Taught in university systems courses
- [ ] Referenced in RFCs and standards
- [ ] Every major framework has integration

== Anti-Goals

**Things we explicitly won't do:**

- ‚ùå Optimize before proving correctness
- ‚ùå Support every format before validating approach
- ‚ùå Compromise the invariant for performance
- ‚ùå Become a full RPC framework (stay focused on data)
- ‚ùå Vendor lock-in (always open source, always portable)

== Open Questions

**Things we need to figure out:**

1. **Naming:** Should generated code reference "squisher"? Or be invisible?
2. **Ownership:** For FFI, who owns the data after crossing boundary?
3. **Versioning:** How to handle schema evolution in adapters?
4. **Caching:** Can we cache generated adapters safely?
5. **Distribution:** Crate, binary, service, or all three?

== Contributing to the Roadmap

**This roadmap is not set in stone.**

If you see:
- A missing format pair that would be impactful
- A hard problem we haven't considered
- A better ordering of phases
- A use case we haven't imagined

‚Üí Open an issue or MR. This is a collaborative exploration.

== Timeline Caveats

**These are estimates, not commitments.**

Hard problems will surface. The invariant might break (we'll fix it or document impossibility). Real-world use cases will reshape priorities.

**The only fixed points:**
1. MVP must prove the invariant
2. Python ‚Üî Rust comes first (maximum impact)
3. We ship incrementally, not big-bang

Everything else is negotiable based on what we learn.
