# SPDX-License-Identifier: PMPL-1.0
# SPDX-FileCopyrightText: 2025 hyperpolymath

"""
Integration tests for PyO3-generated types.

These tests verify that the code generated by protocol-squisher-pyo3-codegen
works correctly when called from Python.
"""

import json
import pytest
from pyo3_integration_test import Status, Address, User, Order, OrderItem


class TestStatus:
    """Tests for the Status enum."""

    def test_enum_values(self):
        """Test that enum values are accessible."""
        assert Status.active is not None
        assert Status.inactive is not None
        assert Status.pending is not None
        assert Status.suspended is not None

    def test_enum_name(self):
        """Test that enum name property works."""
        assert Status.active.name == "Active"
        assert Status.inactive.name == "Inactive"
        assert Status.pending.name == "Pending"
        assert Status.suspended.name == "Suspended"

    def test_enum_value(self):
        """Test that enum value property works."""
        assert Status.active.value == 0
        assert Status.inactive.value == 1
        assert Status.pending.value == 2
        assert Status.suspended.value == 3

    def test_enum_repr(self):
        """Test that enum repr is correct."""
        assert repr(Status.active) == "Status.Active"
        assert repr(Status.inactive) == "Status.Inactive"

    def test_enum_equality(self):
        """Test that enum equality works."""
        assert Status.active == Status.active
        assert Status.active != Status.inactive

    def test_enum_hash(self):
        """Test that enums are hashable (can be used in sets/dicts)."""
        status_set = {Status.active, Status.inactive, Status.active}
        assert len(status_set) == 2

        status_dict = {Status.active: "active user", Status.pending: "pending user"}
        assert status_dict[Status.active] == "active user"


class TestAddress:
    """Tests for the Address struct."""

    def test_create_address(self):
        """Test creating an address."""
        addr = Address("123 Main St", "Springfield", "USA")
        assert addr.street == "123 Main St"
        assert addr.city == "Springfield"
        assert addr.country == "USA"
        assert addr.postal_code is None

    def test_create_address_with_postal_code(self):
        """Test creating an address with postal code."""
        addr = Address("123 Main St", "Springfield", "USA", "12345")
        assert addr.postal_code == "12345"

    def test_address_setters(self):
        """Test that setters work."""
        addr = Address("123 Main St", "Springfield", "USA")
        addr.city = "Shelbyville"
        assert addr.city == "Shelbyville"

    def test_address_repr(self):
        """Test address repr."""
        addr = Address("123 Main St", "Springfield", "USA")
        r = repr(addr)
        assert "123 Main St" in r
        assert "Springfield" in r

    def test_address_to_dict(self):
        """Test converting address to dict."""
        addr = Address("123 Main St", "Springfield", "USA", "12345")
        d = addr.to_dict()
        assert d["street"] == "123 Main St"
        assert d["city"] == "Springfield"
        assert d["country"] == "USA"
        assert d["postal_code"] == "12345"

    def test_address_from_dict(self):
        """Test creating address from dict."""
        d = {
            "street": "456 Oak Ave",
            "city": "Portland",
            "country": "USA",
            "postal_code": "97201",
        }
        addr = Address.from_dict(d)
        assert addr.street == "456 Oak Ave"
        assert addr.city == "Portland"
        assert addr.postal_code == "97201"

    def test_address_json_roundtrip(self):
        """Test JSON serialization roundtrip."""
        addr = Address("123 Main St", "Springfield", "USA", "12345")
        json_str = addr.to_json()
        addr2 = Address.from_json(json_str)
        assert addr2.street == addr.street
        assert addr2.city == addr.city
        assert addr2.country == addr.country
        assert addr2.postal_code == addr.postal_code


class TestUser:
    """Tests for the User struct."""

    def test_create_user_minimal(self):
        """Test creating a user with minimal fields."""
        user = User(1, "Alice", Status.active)
        assert user.id == 1
        assert user.name == "Alice"
        assert user.status == Status.active
        assert user.email is None
        assert user.age is None
        assert user.tags == []
        assert user.address is None

    def test_create_user_full(self):
        """Test creating a user with all fields."""
        addr = Address("123 Main St", "Springfield", "USA")
        user = User(
            id=1,
            name="Alice",
            status=Status.active,
            email="alice@example.com",
            age=30,
            tags=["admin", "vip"],
            address=addr,
        )
        assert user.email == "alice@example.com"
        assert user.age == 30
        assert user.tags == ["admin", "vip"]
        assert user.address.city == "Springfield"

    def test_user_is_active(self):
        """Test the is_active method."""
        active_user = User(1, "Alice", Status.active)
        inactive_user = User(2, "Bob", Status.inactive)

        assert active_user.is_active() is True
        assert inactive_user.is_active() is False

    def test_user_add_tag(self):
        """Test adding tags to a user."""
        user = User(1, "Alice", Status.active)
        user.add_tag("admin")
        user.add_tag("vip")
        user.add_tag("admin")  # Duplicate, should not be added

        assert "admin" in user.tags
        assert "vip" in user.tags
        assert len(user.tags) == 2

    def test_user_setters(self):
        """Test that setters work."""
        user = User(1, "Alice", Status.active)
        user.name = "Alicia"
        user.status = Status.inactive

        assert user.name == "Alicia"
        assert user.status == Status.inactive

    def test_user_to_dict(self):
        """Test converting user to dict."""
        user = User(1, "Alice", Status.active, email="alice@example.com")
        d = user.to_dict()

        assert d["id"] == 1
        assert d["name"] == "Alice"
        assert d["email"] == "alice@example.com"
        assert d["status"] == "Active"

    def test_user_json_roundtrip(self):
        """Test JSON serialization roundtrip."""
        user = User(
            id=1,
            name="Alice",
            status=Status.active,
            email="alice@example.com",
            age=30,
            tags=["admin"],
        )
        json_str = user.to_json()
        user2 = User.from_json(json_str)

        assert user2.id == user.id
        assert user2.name == user.name
        assert user2.email == user.email
        assert user2.age == user.age
        assert user2.tags == user.tags

    def test_user_json_with_nested_address(self):
        """Test JSON with nested address."""
        addr = Address("123 Main St", "Springfield", "USA")
        user = User(1, "Alice", Status.active, address=addr)

        json_str = user.to_json()
        data = json.loads(json_str)

        assert data["address"]["street"] == "123 Main St"
        assert data["address"]["city"] == "Springfield"


class TestOrderItem:
    """Tests for the OrderItem struct."""

    def test_create_order_item(self):
        """Test creating an order item."""
        item = OrderItem(101, "Widget", 2, 9.99)
        assert item.product_id == 101
        assert item.name == "Widget"
        assert item.quantity == 2
        assert item.price == 9.99

    def test_order_item_subtotal(self):
        """Test subtotal calculation."""
        item = OrderItem(101, "Widget", 3, 10.00)
        assert item.subtotal() == 30.00

    def test_order_item_json_roundtrip(self):
        """Test JSON serialization roundtrip."""
        item = OrderItem(101, "Widget", 2, 9.99)
        json_str = item.to_json()
        item2 = OrderItem.from_json(json_str)

        assert item2.product_id == item.product_id
        assert item2.name == item.name
        assert item2.quantity == item.quantity
        assert item2.price == item.price


class TestOrder:
    """Tests for the Order struct."""

    def test_create_order_empty(self):
        """Test creating an empty order."""
        order = Order(1, 100)
        assert order.id == 1
        assert order.user_id == 100
        assert order.items == []
        assert order.total == 0.0
        assert order.shipping_address is None

    def test_create_order_with_items(self):
        """Test creating an order with items."""
        items = [
            OrderItem(101, "Widget", 2, 10.00),
            OrderItem(102, "Gadget", 1, 25.00),
        ]
        order = Order(1, 100, items=items, total=45.00)

        assert len(order.items) == 2
        assert order.total == 45.00

    def test_order_add_item(self):
        """Test adding items to an order."""
        order = Order(1, 100)
        order.add_item(OrderItem(101, "Widget", 2, 10.00))
        order.add_item(OrderItem(102, "Gadget", 1, 25.00))

        assert len(order.items) == 2
        assert order.total == 45.00  # Auto-calculated

    def test_order_calculate_total(self):
        """Test manual total calculation."""
        items = [
            OrderItem(101, "Widget", 2, 10.00),
            OrderItem(102, "Gadget", 1, 25.00),
        ]
        order = Order(1, 100, items=items, total=0.0)
        order.calculate_total()

        assert order.total == 45.00

    def test_order_with_shipping_address(self):
        """Test order with shipping address."""
        addr = Address("123 Main St", "Springfield", "USA", "12345")
        order = Order(1, 100, shipping_address=addr)

        assert order.shipping_address is not None
        assert order.shipping_address.city == "Springfield"

    def test_order_json_roundtrip(self):
        """Test JSON serialization roundtrip."""
        items = [OrderItem(101, "Widget", 2, 10.00)]
        addr = Address("123 Main St", "Springfield", "USA")
        order = Order(1, 100, items=items, total=20.00, shipping_address=addr)

        json_str = order.to_json()
        order2 = Order.from_json(json_str)

        assert order2.id == order.id
        assert order2.user_id == order.user_id
        assert len(order2.items) == 1
        assert order2.items[0].name == "Widget"
        assert order2.total == order.total
        assert order2.shipping_address.city == "Springfield"


class TestInteroperability:
    """Tests for interoperability between types."""

    def test_user_with_nested_address(self):
        """Test user with nested address works end-to-end."""
        addr = Address("123 Main St", "Springfield", "USA", "12345")
        user = User(
            id=1,
            name="Alice",
            status=Status.active,
            email="alice@example.com",
            tags=["vip"],
            address=addr,
        )

        # Note: PyO3 returns copies of nested objects via getter
        # To modify, we must reassign the entire address object
        addr_copy = user.address
        addr_copy.city = "Shelbyville"
        user.address = addr_copy
        assert user.address.city == "Shelbyville"

        # Convert to JSON and back
        json_str = user.to_json()
        user2 = User.from_json(json_str)
        assert user2.address.city == "Shelbyville"

    def test_order_with_multiple_items_and_address(self):
        """Test complex order with items and address."""
        items = [
            OrderItem(101, "Widget", 2, 10.00),
            OrderItem(102, "Gadget", 3, 15.00),
            OrderItem(103, "Gizmo", 1, 50.00),
        ]
        addr = Address("456 Oak Ave", "Portland", "USA", "97201")
        order = Order(
            id=1001,
            user_id=42,
            items=items,
            total=0.0,
            shipping_address=addr,
        )
        order.calculate_total()

        # Verify total: 2*10 + 3*15 + 1*50 = 20 + 45 + 50 = 115
        assert order.total == 115.00

        # JSON roundtrip
        json_str = order.to_json()
        order2 = Order.from_json(json_str)

        assert order2.total == 115.00
        assert len(order2.items) == 3
        assert order2.shipping_address.postal_code == "97201"

    def test_json_interop_with_python_json_module(self):
        """Test that JSON output is valid Python JSON."""
        user = User(1, "Alice", Status.active, email="alice@example.com")
        json_str = user.to_json()

        # Parse with Python's json module
        data = json.loads(json_str)

        assert data["id"] == 1
        assert data["name"] == "Alice"
        assert data["email"] == "alice@example.com"
        assert data["status"] == "Active"

    def test_enum_in_collections(self):
        """Test that enums work in Python collections."""
        statuses = [Status.active, Status.pending, Status.inactive]
        assert len(statuses) == 3
        assert Status.active in statuses

        status_counts = {
            Status.active: 10,
            Status.inactive: 5,
            Status.pending: 3,
        }
        assert status_counts[Status.active] == 10


class TestErrorHandling:
    """Tests for error handling."""

    def test_invalid_json_raises_error(self):
        """Test that invalid JSON raises an error."""
        with pytest.raises(ValueError):
            User.from_json("not valid json")

    def test_missing_required_field_in_dict(self):
        """Test that missing required field raises KeyError."""
        with pytest.raises(KeyError):
            Address.from_dict({"street": "123 Main St"})  # Missing city and country

    def test_wrong_type_in_json(self):
        """Test that wrong type in JSON raises error."""
        # id should be int, not string
        bad_json = '{"id": "not-a-number", "name": "Alice", "status": "Active", "tags": []}'
        with pytest.raises(ValueError):
            User.from_json(bad_json)
