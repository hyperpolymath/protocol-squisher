// SPDX-License-Identifier: PMPL-1.0-or-later
// SPDX-FileCopyrightText: 2025 Jonathan D.A. Jewell

//! PyO3 Integration Test Module
//!
//! This module contains types generated by protocol-squisher-pyo3-codegen
//! to test that the generated code compiles and works correctly from Python.

use pyo3::prelude::*;
use pyo3::types::PyDict;
use serde::{Deserialize, Serialize};

// ============================================================================
// Enum: Status
// ============================================================================

/// Account status enumeration
#[pyclass(eq, frozen, hash)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum Status {
    Active = 0,
    Inactive = 1,
    Pending = 2,
    Suspended = 3,
}

#[pymethods]
impl Status {
    #[classattr]
    fn active() -> Self {
        Self::Active
    }

    #[classattr]
    fn inactive() -> Self {
        Self::Inactive
    }

    #[classattr]
    fn pending() -> Self {
        Self::Pending
    }

    #[classattr]
    fn suspended() -> Self {
        Self::Suspended
    }

    fn __repr__(&self) -> String {
        match self {
            Self::Active => "Status.Active".to_string(),
            Self::Inactive => "Status.Inactive".to_string(),
            Self::Pending => "Status.Pending".to_string(),
            Self::Suspended => "Status.Suspended".to_string(),
        }
    }

    #[getter]
    fn name(&self) -> &'static str {
        match self {
            Self::Active => "Active",
            Self::Inactive => "Inactive",
            Self::Pending => "Pending",
            Self::Suspended => "Suspended",
        }
    }

    #[getter]
    fn value(&self) -> usize {
        *self as usize
    }
}

// ============================================================================
// Struct: Address
// ============================================================================

/// A physical address
#[pyclass]
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Address {
    #[pyo3(get, set)]
    pub street: String,
    #[pyo3(get, set)]
    pub city: String,
    #[pyo3(get, set)]
    pub country: String,
    #[pyo3(get, set)]
    pub postal_code: Option<String>,
}

#[pymethods]
impl Address {
    #[new]
    #[pyo3(signature = (street, city, country, postal_code=None))]
    pub fn new(street: String, city: String, country: String, postal_code: Option<String>) -> Self {
        Self {
            street,
            city,
            country,
            postal_code,
        }
    }

    fn __repr__(&self) -> String {
        format!(
            "Address(street={:?}, city={:?}, country={:?}, postal_code={:?})",
            self.street, self.city, self.country, self.postal_code
        )
    }

    /// Convert to a Python dictionary
    pub fn to_dict(&self, py: Python<'_>) -> PyResult<Py<pyo3::types::PyAny>> {
        let dict = PyDict::new(py);
        dict.set_item("street", &self.street)?;
        dict.set_item("city", &self.city)?;
        dict.set_item("country", &self.country)?;
        dict.set_item("postal_code", &self.postal_code)?;
        Ok(dict.unbind().into_any())
    }

    /// Create from a Python dictionary
    #[staticmethod]
    pub fn from_dict(dict: &Bound<'_, PyDict>) -> PyResult<Address> {
        let street: String = dict
            .get_item("street")?
            .ok_or_else(|| pyo3::exceptions::PyKeyError::new_err("street"))?
            .extract()?;
        let city: String = dict
            .get_item("city")?
            .ok_or_else(|| pyo3::exceptions::PyKeyError::new_err("city"))?
            .extract()?;
        let country: String = dict
            .get_item("country")?
            .ok_or_else(|| pyo3::exceptions::PyKeyError::new_err("country"))?
            .extract()?;
        let postal_code: Option<String> = dict
            .get_item("postal_code")?
            .map(|v| v.extract())
            .transpose()?;
        Ok(Address {
            street,
            city,
            country,
            postal_code,
        })
    }

    /// Serialize to JSON string
    pub fn to_json(&self) -> PyResult<String> {
        serde_json::to_string(self)
            .map_err(|e| pyo3::exceptions::PyValueError::new_err(e.to_string()))
    }

    /// Deserialize from JSON string
    #[staticmethod]
    pub fn from_json(json: &str) -> PyResult<Address> {
        serde_json::from_str(json)
            .map_err(|e| pyo3::exceptions::PyValueError::new_err(e.to_string()))
    }
}

// ============================================================================
// Struct: User
// ============================================================================

/// A user in the system
#[pyclass]
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct User {
    #[pyo3(get, set)]
    pub id: i64,
    #[pyo3(get, set)]
    pub name: String,
    #[pyo3(get, set)]
    pub email: Option<String>,
    #[pyo3(get, set)]
    pub age: Option<i64>,
    #[pyo3(get, set)]
    pub status: Status,
    #[pyo3(get, set)]
    pub tags: Vec<String>,
    #[pyo3(get, set)]
    pub address: Option<Address>,
}

#[pymethods]
impl User {
    #[new]
    #[pyo3(signature = (id, name, status, email=None, age=None, tags=None, address=None))]
    pub fn new(
        id: i64,
        name: String,
        status: Status,
        email: Option<String>,
        age: Option<i64>,
        tags: Option<Vec<String>>,
        address: Option<Address>,
    ) -> Self {
        Self {
            id,
            name,
            email,
            age,
            status,
            tags: tags.unwrap_or_default(),
            address,
        }
    }

    fn __repr__(&self) -> String {
        format!(
            "User(id={}, name={:?}, email={:?}, age={:?}, status={:?}, tags={:?})",
            self.id, self.name, self.email, self.age, self.status, self.tags
        )
    }

    /// Convert to a Python dictionary
    pub fn to_dict(&self, py: Python<'_>) -> PyResult<Py<pyo3::types::PyAny>> {
        let dict = PyDict::new(py);
        dict.set_item("id", self.id)?;
        dict.set_item("name", &self.name)?;
        dict.set_item("email", &self.email)?;
        dict.set_item("age", self.age)?;
        dict.set_item("status", self.status.name())?;
        dict.set_item("tags", &self.tags)?;
        if let Some(ref addr) = self.address {
            dict.set_item("address", addr.to_dict(py)?)?;
        } else {
            dict.set_item("address", py.None())?;
        }
        Ok(dict.unbind().into_any())
    }

    /// Serialize to JSON string
    pub fn to_json(&self) -> PyResult<String> {
        serde_json::to_string(self)
            .map_err(|e| pyo3::exceptions::PyValueError::new_err(e.to_string()))
    }

    /// Deserialize from JSON string
    #[staticmethod]
    pub fn from_json(json: &str) -> PyResult<User> {
        serde_json::from_str(json)
            .map_err(|e| pyo3::exceptions::PyValueError::new_err(e.to_string()))
    }

    /// Check if user is active
    pub fn is_active(&self) -> bool {
        matches!(self.status, Status::Active)
    }

    /// Add a tag to the user
    pub fn add_tag(&mut self, tag: String) {
        if !self.tags.contains(&tag) {
            self.tags.push(tag);
        }
    }
}

// ============================================================================
// Struct: Order (demonstrates nested types and lists)
// ============================================================================

/// An order in the system
#[pyclass]
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Order {
    #[pyo3(get, set)]
    pub id: i64,
    #[pyo3(get, set)]
    pub user_id: i64,
    #[pyo3(get, set)]
    pub items: Vec<OrderItem>,
    #[pyo3(get, set)]
    pub total: f64,
    #[pyo3(get, set)]
    pub shipping_address: Option<Address>,
}

#[pymethods]
impl Order {
    #[new]
    #[pyo3(signature = (id, user_id, items=None, total=0.0, shipping_address=None))]
    pub fn new(
        id: i64,
        user_id: i64,
        items: Option<Vec<OrderItem>>,
        total: f64,
        shipping_address: Option<Address>,
    ) -> Self {
        Self {
            id,
            user_id,
            items: items.unwrap_or_default(),
            total,
            shipping_address,
        }
    }

    fn __repr__(&self) -> String {
        format!(
            "Order(id={}, user_id={}, items={}, total={})",
            self.id,
            self.user_id,
            self.items.len(),
            self.total
        )
    }

    /// Calculate total from items
    pub fn calculate_total(&mut self) {
        self.total = self.items.iter().map(|item| item.price * item.quantity as f64).sum();
    }

    /// Add an item to the order
    pub fn add_item(&mut self, item: OrderItem) {
        self.items.push(item);
        self.calculate_total();
    }

    /// Serialize to JSON string
    pub fn to_json(&self) -> PyResult<String> {
        serde_json::to_string(self)
            .map_err(|e| pyo3::exceptions::PyValueError::new_err(e.to_string()))
    }

    /// Deserialize from JSON string
    #[staticmethod]
    pub fn from_json(json: &str) -> PyResult<Order> {
        serde_json::from_str(json)
            .map_err(|e| pyo3::exceptions::PyValueError::new_err(e.to_string()))
    }
}

// ============================================================================
// Struct: OrderItem
// ============================================================================

/// An item in an order
#[pyclass]
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct OrderItem {
    #[pyo3(get, set)]
    pub product_id: i64,
    #[pyo3(get, set)]
    pub name: String,
    #[pyo3(get, set)]
    pub quantity: i64,
    #[pyo3(get, set)]
    pub price: f64,
}

#[pymethods]
impl OrderItem {
    #[new]
    pub fn new(product_id: i64, name: String, quantity: i64, price: f64) -> Self {
        Self {
            product_id,
            name,
            quantity,
            price,
        }
    }

    fn __repr__(&self) -> String {
        format!(
            "OrderItem(product_id={}, name={:?}, quantity={}, price={})",
            self.product_id, self.name, self.quantity, self.price
        )
    }

    /// Get the subtotal for this item
    pub fn subtotal(&self) -> f64 {
        self.price * self.quantity as f64
    }

    /// Serialize to JSON string
    pub fn to_json(&self) -> PyResult<String> {
        serde_json::to_string(self)
            .map_err(|e| pyo3::exceptions::PyValueError::new_err(e.to_string()))
    }

    /// Deserialize from JSON string
    #[staticmethod]
    pub fn from_json(json: &str) -> PyResult<OrderItem> {
        serde_json::from_str(json)
            .map_err(|e| pyo3::exceptions::PyValueError::new_err(e.to_string()))
    }
}

// ============================================================================
// Module Registration
// ============================================================================

/// PyO3 Integration Test Module
///
/// This module demonstrates the types generated by protocol-squisher.
#[pymodule]
fn pyo3_integration_test(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<Status>()?;
    m.add_class::<Address>()?;
    m.add_class::<User>()?;
    m.add_class::<Order>()?;
    m.add_class::<OrderItem>()?;
    Ok(())
}
