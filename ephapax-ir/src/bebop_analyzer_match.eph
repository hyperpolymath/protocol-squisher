// Bebop analyzer rewritten with pattern matching

fn bebop_int32() -> i32 { 1 }
fn bebop_int64() -> i32 { 2 }
fn bebop_uint32() -> i32 { 3 }
fn bebop_uint64() -> i32 { 4 }
fn bebop_float32() -> i32 { 5 }
fn bebop_float64() -> i32 { 6 }
fn bebop_bool() -> i32 { 7 }
fn bebop_string() -> i32 { 8 }
fn bebop_byte() -> i32 { 9 }

fn ir_i32() -> i32 { 10 }
fn ir_i64() -> i32 { 11 }
fn ir_u32() -> i32 { 12 }
fn ir_u64() -> i32 { 13 }
fn ir_f32() -> i32 { 14 }
fn ir_f64() -> i32 { 15 }
fn ir_bool() -> i32 { 16 }
fn ir_string() -> i32 { 17 }
fn ir_byte() -> i32 { 18 }

fn bebop_to_ir(bebop_type: i32) -> i32 {
    match bebop_type {
        1 => ir_i32(),
        2 => ir_i64(),
        3 => ir_u32(),
        4 => ir_u64(),
        5 => ir_f32(),
        6 => ir_f64(),
        7 => ir_bool(),
        8 => ir_string(),
        _ => ir_byte()
    }
}

fn is_zero_copy(bebop_type: i32) -> bool {
    match bebop_type {
        1 => true,
        2 => true,
        5 => true,
        6 => true,
        7 => true,
        _ => false
    }
}

fn calculate_squishability_inner(bebop_type: i32) -> i32 {
    match bebop_type {
        8 => 60,
        _ => 40
    }
}

fn calculate_squishability(bebop_type: i32) -> i32 {
    let zero_copy = is_zero_copy(bebop_type);
    match zero_copy {
        true => 0,
        false => calculate_squishability_inner(bebop_type)
    }
}

fn analyze_field(field_type: i32) -> i32 {
    let ir_type = bebop_to_ir(field_type);
    let zero_copy = is_zero_copy(field_type);
    let squish = calculate_squishability(field_type);
    ir_type + squish
}

fn main() {
    let field1 = bebop_int32();
    let field2 = bebop_string();
    let field3 = bebop_float64();

    let score1 = analyze_field(field1);
    let score2 = analyze_field(field2);
    let score3 = analyze_field(field3);

    score1 + score2 + score3
}
