// SPDX-License-Identifier: PMPL-1.0-or-later
// SPDX-FileCopyrightText: 2026 Jonathan D.A. Jewell
// Protocol Squisher - Canonical IR Type System (ephapax)
//
// This module encodes IR types using integer tags, demonstrating
// linear type guarantees for protocol-squisher's IR operations.
//
// Compilation: ephapax compile src/types.eph -o target/types.wasm

// ============================================================================
// Primitive Type Tags
// ============================================================================

fn prim_i8() -> i32 { 0 }
fn prim_i16() -> i32 { 1 }
fn prim_i32() -> i32 { 2 }
fn prim_i64() -> i32 { 3 }
fn prim_u8() -> i32 { 4 }
fn prim_u16() -> i32 { 5 }
fn prim_u32() -> i32 { 6 }
fn prim_u64() -> i32 { 7 }
fn prim_f32() -> i32 { 8 }
fn prim_f64() -> i32 { 9 }
fn prim_bool() -> i32 { 10 }
fn prim_char() -> i32 { 11 }
fn prim_string() -> i32 { 12 }
fn prim_unit() -> i32 { 13 }

// ============================================================================
// Container Type Tags
// ============================================================================

fn container_array() -> i32 { 20 }
fn container_vec() -> i32 { 21 }
fn container_map() -> i32 { 22 }
fn container_set() -> i32 { 23 }
fn container_optional() -> i32 { 24 }

// ============================================================================
// Composite Type Tags
// ============================================================================

fn composite_struct() -> i32 { 30 }
fn composite_enum() -> i32 { 31 }
fn composite_tuple() -> i32 { 32 }

// ============================================================================
// Type Compatibility Checking
// ============================================================================

// Check if two primitive types are compatible
fn primitives_compatible(a: i32, b: i32) -> bool {
    if a == b {
        true
    } else {
        // Numeric widening allowed
        let widening_allowed =
            (a == prim_i8() && (b == prim_i16() || b == prim_i32() || b == prim_i64())) ||
            (a == prim_i16() && (b == prim_i32() || b == prim_i64())) ||
            (a == prim_i32() && b == prim_i64()) ||
            (a == prim_u8() && (b == prim_u16() || b == prim_u32() || b == prim_u64())) ||
            (a == prim_u16() && (b == prim_u32() || b == prim_u64())) ||
            (a == prim_u32() && b == prim_u64()) ||
            (a == prim_f32() && b == prim_f64());
        widening_allowed
    }
}

// Check if a type is a primitive
fn is_primitive(ty: i32) -> bool {
    ty >= prim_i8() && ty <= prim_unit()
}

// Check if a type is a container
fn is_container(ty: i32) -> bool {
    ty >= container_array() && ty <= container_optional()
}

// Check if a type is a composite
fn is_composite(ty: i32) -> bool {
    ty >= composite_struct() && ty <= composite_tuple()
}

// ============================================================================
// Primitive Type Queries
// ============================================================================

fn is_integer_type(ty: i32) -> bool {
    (ty >= prim_i8() && ty <= prim_i64()) || (ty >= prim_u8() && ty <= prim_u64())
}

fn is_float_type(ty: i32) -> bool {
    ty == prim_f32() || ty == prim_f64()
}

fn is_numeric_type(ty: i32) -> bool {
    is_integer_type(ty) || is_float_type(ty)
}

// ============================================================================
// Type Size Calculation (for memory layout)
// ============================================================================

fn type_size_bytes(ty: i32) -> i32 {
    if ty == prim_i8() { 1 }
    else { if ty == prim_i16() { 2 }
    else { if ty == prim_i32() { 4 }
    else { if ty == prim_i64() { 8 }
    else { if ty == prim_u8() { 1 }
    else { if ty == prim_u16() { 2 }
    else { if ty == prim_u32() { 4 }
    else { if ty == prim_u64() { 8 }
    else { if ty == prim_f32() { 4 }
    else { if ty == prim_f64() { 8 }
    else { if ty == prim_bool() { 1 }
    else { if ty == prim_char() { 4 }
    else { if ty == prim_string() { 8 }
    else { if ty == prim_unit() { 0 }
    else { 0 }}}}}}}}}}}}}
}

// ============================================================================
// Type Validation
// ============================================================================

// Validate that a type tag is well-formed
fn validate_type_tag(ty: i32) -> bool {
    is_primitive(ty) || is_container(ty) || is_composite(ty)
}

// ============================================================================
// Entry Point for Testing
// ============================================================================

fn main() -> i32 {
    // Test primitive compatibility
    let compatible = primitives_compatible(prim_i32(), prim_i64());

    // Test type size
    let size = type_size_bytes(prim_i32());

    // Test validation
    let valid = validate_type_tag(prim_string());

    // Return success if all tests pass
    if compatible && size == 4 && valid {
        0
    } else {
        1
    }
}
