// SPDX-License-Identifier: PMPL-1.0-or-later
// SPDX-FileCopyrightText: 2026 Jonathan D.A. Jewell
// Protocol Squisher - Compatibility Analysis (ephapax)
//
// This module implements transport class classification using integer encoding.
// Linear types ensure compatibility analysis happens exactly once per type pair.
//
// Compilation: ephapax compile src/compat.eph -o target/compat.wasm

// ============================================================================
// Transport Class Tags
// ============================================================================

fn transport_concorde() -> i32 { 100 }    // Zero-copy, 100% fidelity
fn transport_business() -> i32 { 101 }    // Minor overhead, 95-100% fidelity
fn transport_economy() -> i32 { 102 }     // Moderate overhead, 70-95% fidelity
fn transport_wheelbarrow() -> i32 { 103 } // High overhead, <70% fidelity

// ============================================================================
// Fidelity Calculation
// ============================================================================

fn fidelity_perfect() -> i32 { 100 }
fn fidelity_excellent() -> i32 { 98 }
fn fidelity_good() -> i32 { 80 }
fn fidelity_minimal() -> i32 { 50 }

// ============================================================================
// Overhead Calculation (percentage)
// ============================================================================

fn overhead_zero() -> i32 { 0 }
fn overhead_low() -> i32 { 5 }
fn overhead_medium() -> i32 { 25 }
fn overhead_high() -> i32 { 80 }

// ============================================================================
// Type Compatibility Analysis
// ============================================================================

// Analyze compatibility between two primitive types
// Returns transport class tag
fn analyze_primitive_compat(source: i32, target: i32) -> i32 {
    if source == target {
        // Exact match: Concorde class (zero-copy possible)
        transport_concorde()
    } else {
        // Check if widening conversion is safe
        let can_widen =
            (source == 2 && target == 3) ||  // i32 -> i64
            (source == 8 && target == 9);     // f32 -> f64

        if can_widen {
            // Safe widening: Business class
            transport_business()
        } else {
            // Incompatible: Wheelbarrow (JSON fallback required)
            transport_wheelbarrow()
        }
    }
}

// Analyze compatibility between container types
fn analyze_container_compat(source_container: i32, target_container: i32) -> i32 {
    if source_container == target_container {
        // Same container type: Business class (element conversion may be needed)
        transport_business()
    } else {
        // Different containers: Economy class (conversion overhead)
        transport_economy()
    }
}

// Analyze compatibility between composite types
fn analyze_composite_compat(source_composite: i32, target_composite: i32) -> i32 {
    if source_composite == target_composite {
        // Same composite kind: Business class
        transport_business()
    } else {
        // Different composites: Wheelbarrow (major structural mismatch)
        transport_wheelbarrow()
    }
}

// ============================================================================
// Compatibility Classification
// ============================================================================

// Classify compatibility and return fidelity percentage
fn get_fidelity(transport_class: i32) -> i32 {
    if transport_class == transport_concorde() {
        fidelity_perfect()
    } else { if transport_class == transport_business() {
        fidelity_excellent()
    } else { if transport_class == transport_economy() {
        fidelity_good()
    } else {
        fidelity_minimal()
    }}}
}

// Get overhead percentage for transport class
fn get_overhead(transport_class: i32) -> i32 {
    if transport_class == transport_concorde() {
        overhead_zero()
    } else { if transport_class == transport_business() {
        overhead_low()
    } else { if transport_class == transport_economy() {
        overhead_medium()
    } else {
        overhead_high()
    }}}
}

// ============================================================================
// The Invariant: Guaranteed Transport
// ============================================================================

// This function ALWAYS returns a valid transport class
// Proving the invariant: "If it compiles, it carries"
fn analyze_compatibility(source: i32, target: i32) -> i32 {
    // Classify types
    let source_is_prim = source >= 0 && source <= 13;
    let target_is_prim = target >= 0 && target <= 13;

    let source_is_cont = source >= 20 && source <= 24;
    let target_is_cont = target >= 20 && target <= 24;

    let source_is_comp = source >= 30 && source <= 32;
    let target_is_comp = target >= 30 && target <= 32;

    // Analyze based on type categories
    if source_is_prim && target_is_prim {
        analyze_primitive_compat(source, target)
    } else { if source_is_cont && target_is_cont {
        analyze_container_compat(source, target)
    } else { if source_is_comp && target_is_comp {
        analyze_composite_compat(source, target)
    } else {
        // Complete mismatch: Wheelbarrow (JSON fallback)
        // This ensures the invariant: ALWAYS returns a transport class
        transport_wheelbarrow()
    }}}
}

// ============================================================================
// Verification: The Invariant Holds
// ============================================================================

// Verify that analyze_compatibility ALWAYS returns a valid transport class
fn verify_invariant(source: i32, target: i32) -> bool {
    let result = analyze_compatibility(source, target);

    // Check result is a valid transport class
    result == transport_concorde() ||
    result == transport_business() ||
    result == transport_economy() ||
    result == transport_wheelbarrow()
}

// ============================================================================
// Entry Point for Testing
// ============================================================================

fn main() -> i32 {
    // Test 1: Exact match (Concorde)
    let test1 = analyze_compatibility(2, 2);  // i32 -> i32
    let expect1 = test1 == transport_concorde();

    // Test 2: Widening (Business)
    let test2 = analyze_compatibility(2, 3);  // i32 -> i64
    let expect2 = test2 == transport_business();

    // Test 3: Mismatch (Wheelbarrow)
    let test3 = analyze_compatibility(2, 12); // i32 -> string
    let expect3 = test3 == transport_wheelbarrow();

    // Test 4: Invariant verification
    let verify1 = verify_invariant(2, 2);
    let verify2 = verify_invariant(2, 12);
    let verify3 = verify_invariant(30, 31);

    // Return 0 if all tests pass
    if expect1 && expect2 && expect3 && verify1 && verify2 && verify3 {
        0
    } else {
        1
    }
}
