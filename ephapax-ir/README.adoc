// SPDX-License-Identifier: PMPL-1.0-or-later
// SPDX-FileCopyrightText: 2026 Jonathan D.A. Jewell
= ephapax-ir: Protocol Squisher Canonical IR

**The intermediate representation for protocol-squisher, implemented in ephapax.**

== Why ephapax?

The protocol-squisher IR is written in ephapax (linear type system) to guarantee:

[cols="1,3"]
|===
| Guarantee | Mechanism

| **Zero-copy safety**
| Linear types prove no aliasing in zero-copy paths

| **No resource leaks**
| Types consumed exactly once - serialization buffers freed correctly

| **Memory-safe FFI**
| Ownership transfer across Rust↔Python proven at compile time

| **Formal verification**
| IR invariants backed by Coq proofs (via ephapax)
|===

== The Invariant

**"If it compiles, it carries"**

The compatibility analysis (`compat.eph`) proves that for ANY source and target types:
- A transport class exists (Concorde/Business/Economy/Wheelbarrow)
- Transport is guaranteed (even if via JSON fallback)
- Losses are documented before runtime

Linear types ensure this analysis happens exactly once per type pair.

== Structure

```
ephapax-ir/
├── src/
│   ├── types.eph       # Core IR type system
│   ├── compat.eph      # Compatibility analysis
│   └── json.eph        # JSON fallback (TODO)
├── tests/
│   └── invariant.eph   # Property tests for invariant
└── target/
    └── *.wasm          # Compiled WASM modules
```

== Building

```bash
# Compile to WASM
ephapax-cli compile src/types.eph -o target/types.wasm
ephapax-cli compile src/compat.eph -o target/compat.wasm

# Or via justfile from protocol-squisher root
just build-ir
```

== FFI Integration

Rust crates call the ephapax IR via WASM FFI:

```rust
// In protocol-squisher-rust-analyzer
use protocol_squisher_ir::IRContext;

let mut ctx = IRContext::new()?;
let ir_type = ctx.create_struct(fields)?;
let compat = ctx.analyze_compatibility(source_type, target_type)?;
```

== Transport Classes

| Class | Fidelity | Overhead | Example |
|-------|----------|----------|---------|
| **Concorde** | 100% | ~0% | serde ↔ serde (same Rust types) |
| **Business** | 95-100% | <10% | Protobuf ↔ Thrift |
| **Economy** | 70-95% | 10-50% | JSON ↔ MessagePack |
| **Wheelbarrow** | <70% | >50% | Factor ↔ Cap'n Proto (via JSON) |

== Benefits for ephapax

This is a **real-world ephapax program** that:
- Stresses the linear type system with practical constraints
- Tests region-based memory with serialization buffers
- Validates WASM compilation with complex use case
- Proves ephapax is production-ready for systems programming

== Benefits for protocol-squisher

- Zero-copy paths proven safe (no aliasing bugs)
- Memory safety at FFI boundaries
- Formal verification of IR invariants
- No resource leaks in generated adapters

== Next Steps

1. Implement JSON fallback (`json.eph`)
2. Add property tests for invariant
3. Integrate with Rust analyzers via WASM FFI
4. Benchmark zero-copy vs JSON fallback paths
